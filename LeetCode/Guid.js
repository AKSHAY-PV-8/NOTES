// ğŸŸ¡ PHASE 1 â€” HEAP / PRIORITY QUEUE (1â€“2 WEEKS)
// Why?

// Because your Q3 (K sorted lists) was 100% heap-based.

// Core pattern:

// â€œRepeatedly pick min/max from many sourcesâ€

// Must-learn concepts:

// Min Heap

// Max Heap

// Custom comparator

// Heap of {value, listIndex, elementIndex}

// LeetCode (DO IN ORDER):

// Kth Largest Element

// Merge K Sorted Lists

// Top K Frequent Elements

// K Closest Points to Origin

// ğŸ’¡ After this, Q3 becomes EASY

// ğŸŸ¡ PHASE 2 â€” BFS / DFS (2 WEEKS)
// Why?

// Because grid + robot + matrix problems = graph traversal

// Learn these as templates (MEMORIZE):
// DFS template
// dfs(r, c) {
//     if (invalid) return
//     mark visited
//     for each direction
//         dfs(next)
// }

// BFS template
// queue = [start]
// while queue not empty:
//     process level

// LeetCode:

// Number of Islands

// Max Area of Island

// Rotting Oranges

// Flood Fill

// ğŸ‘‰ After this, Q4 (reverse gravity) becomes manageable.

// ğŸŸ¡ PHASE 3 â€” MATRIX / GRID MANIPULATION (1 WEEK)
// Pattern:

// Fix one direction â†’ compress â†’ rebuild

// Your gravity question = column-wise compression

// Learn:

// Iterate column-wise

// Count blocks

// Rewrite grid

// LeetCode:

// Set Matrix Zeroes

// Rotate Image

// Game of Life

// Spiral Matrix

// ğŸŸ¡ PHASE 4 â€” BACKTRACKING (1 WEEK)
// Pattern:

// Try all paths, undo choices

// LeetCode:

// Word Search

// Permutations

// Combinations

// ğŸŸ¡ PHASE 5 â€” DYNAMIC PROGRAMMING (2â€“3 WEEKS)
// Learn DP in THIS ORDER:

// 1D DP (climbing stairs)

// 2D DP (grid paths)

// DP on strings

// LeetCode:

// Climbing Stairs

// Unique Paths

// Minimum Path Sum

// Longest Common Subsequence

// ğŸ”´ PHASE 6 â€” DIJKSTRA / 0-1 BFS (ADVANCED)
// Use when:

// Cost / effort / weights

// LeetCode:

// Minimum Effort Path

// Path With Minimum Cost

// Shortest Path in Grid with Obstacles

// ğŸ§  HOW TO THINK IN INTERVIEWS (IMPORTANT)

// When you see a question, ask:

// â“ 1. Am I picking repeatedly?

// â¡ï¸ Heap

// â“ 2. Shortest path?

// â¡ï¸ BFS

// â“ 3. Count ways?

// â¡ï¸ DP

// â“ 4. Explore all?

// â¡ï¸ DFS

// â“ 5. Grid transform?

// â¡ï¸ Matrix logic

// ğŸ§ª HOW TO PRACTICE (MOST IMPORTANT PART)

// âŒ Donâ€™t solve 100 random problems
// âœ… Solve 20 problems per pattern

// Rule:

// Solve

// Dry run

// Rewrite from memory

// Explain out loud

// ğŸ§  YOUR NEXT 7 DAYS PLAN (START NOW)
// Day 1â€“2

// Heaps basics

// Kth largest

// Top K frequent

// Day 3â€“4

// Merge K sorted lists

// Custom heap comparator

// Day 5

// Number of Islands

// Flood Fill

// Day 6

// Matrix rotate

// Set matrix zeroes

// Day 7

// Revise + re-solve failed ones

// ğŸ’ª IMPORTANT REALITY CHECK

// You are NOT weak.
// You were just untrained for pattern-based tests.

// Once you train:

// These questions become predictable

// You stop panicking

// You start seeing patterns instantly

// ğŸ¤ I CAN GUIDE YOU STEP-BY-STEP

// If you want, we can:

// Start from Heap (tomorrow)

// Solve one pattern per day

// I explain â†’ you code â†’ I debug

// ğŸ‘‰ Reply with:
// â€œStart with Heapâ€ or â€œStart with BFSâ€

// Iâ€™ll take you there ğŸ’¯